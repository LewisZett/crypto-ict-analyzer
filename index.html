<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypto ICT Sniper App</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 10px; background: #f4f4f4; }
        button { background: #007bff; color: white; padding: 10px; border: none; border-radius: 5px; width: 100%; font-size: 16px; }
        #output { margin-top: 20px; white-space: pre-wrap; background: white; padding: 10px; border-radius: 5px; overflow: auto; }
        h1, h2 { color: #333; }
        .error { color: red; }
        .success { color: green; }
        input { width: 100%; padding: 10px; margin: 5px 0; border: 1px solid #ccc; border-radius: 5px; }
        .long { color: green; font-weight: bold; }
        .short { color: red; font-weight: bold; }
    </style>
</head>
<body>
    <h1>Crypto ICT Price Action Analysis App</h1>
    <p>Now integrated with Google Gemini AI for advanced ICT analysis (requires free API key from <a href="https://aistudio.google.com/app/apikey" target="_blank">Google AI Studio</a>).</p>
    <label for="geminiKey">Gemini API Key:</label>
    <input type="password" id="geminiKey" placeholder="Paste your Gemini API key here">
    <button onclick="runAnalysis()">Run ICT Analysis (Both Bullish & Bearish)</button>
    <div id="output"></div>

    <script>
        // No API key needed for public mode
        const API_KEY = ''; // Empty for free public API
        const BASE_URL = 'https://api.coingecko.com/api/v3'; // Public endpoint
        const HEADERS = {}; // No auth headers

        let GEMINI_API_KEY = '';

        async function callGemini(prompt) {
            if (!GEMINI_API_KEY) {
                throw new Error('Gemini API key not provided');
            }
            const url = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent';
            const body = {
                contents: [{
                    parts: [{ text: prompt }]
                }]
            };
            const res = await fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-goog-api-key': GEMINI_API_KEY
                },
                body: JSON.stringify(body)
            });
            if (!res.ok) {
                const errorText = await res.text();
                throw new Error(`Gemini API error (${res.status}): ${errorText}`);
            }
            const data = await res.json();
            const text = data.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!text) {
                throw new Error('No response from Gemini');
            }
            // Extract JSON from response (handle markdown if present)
            const jsonMatch = text.match(/```json\s*(\{.*?\})\s*```/s) || [null, text.trim()];
            try {
                return JSON.parse(jsonMatch[1]);
            } catch (e) {
                throw new Error(`Failed to parse JSON from Gemini: ${e.message}`);
            }
        }

        async function runAnalysis() {
            GEMINI_API_KEY = document.getElementById('geminiKey').value.trim();
            const output = document.getElementById('output');
            output.innerHTML = 'Analyzing... (may take 1-2 min due to API calls)\n';
            
            if (!GEMINI_API_KEY) {
                output.innerHTML += '<span class="error">Please enter your Gemini API key!</span>\n';
                return;
            }
            
            try {
                // Step 0: Get current time in GMT+2 (Johannesburg)
                const now = new Date();
                const saOptions = { timeZone: 'Africa/Johannesburg', hour: 'numeric', minute: 'numeric', hour12: false };
                const saTime = now.toLocaleTimeString('en-US', saOptions);
                const [hourStr, minStr] = saTime.split(':');
                const hour = parseInt(hourStr);
                const minute = parseInt(minStr);
                const isLKZ = (hour >= 9 && hour < 12);
                const isNYKZ = (hour >= 15 && (hour > 15 || minute >= 30) && hour < 18);
                const isAsian = (hour >= 1 && hour < 9);
                const inKillZone = isLKZ || isNYKZ;
                const timeNote = `Current time: ${saTime} GMT+2 | Kill Zone: ${inKillZone ? 'Yes (High Prob)' : 'No (Use Asian Bias)'} | LKZ: ${isLKZ}, NYKZ: ${isNYKZ}, Asian: ${isAsian}`;

                output.innerHTML += `${timeNote}\n`;
                output.innerHTML += `Using Gemini AI for ICT analysis (API key set). Scanning both bullish (>3% 24h) and bearish (<-3% 24h) momentum.\n\n`;

                // Fetch top 50 cryptos
                const marketsUrl = `${BASE_URL}/coins/markets`;
                const marketsParams = new URLSearchParams({
                    vs_currency: 'usd',
                    order: 'market_cap_desc',
                    per_page: 50,
                    page: 1,
                    sparkline: false,
                    price_change_percentage: '24h'
                });
                const marketsRes = await fetch(`${marketsUrl}?${marketsParams}`, { headers: HEADERS });
                
                if (!marketsRes.ok) {
                    const errorText = await marketsRes.text();
                    output.innerHTML += `<span class="error">API Error (${marketsRes.status}): ${errorText}</span>\n`;
                    return;
                }
                
                const topCryptosRaw = await marketsRes.json();
                if (!Array.isArray(topCryptosRaw)) {
                    output.innerHTML += `<span class="error">Invalid API response (not an array): ${JSON.stringify(topCryptosRaw)}</span>\n`;
                    return;
                }
                const topCryptos = topCryptosRaw;

                // Filter candidates: 10 bullish and 10 bearish to respect rate limits
                const bullishCandidates = topCryptos.filter(coin => coin.price_change_percentage_24h > 3).slice(0, 10);
                const bearishCandidates = topCryptos.filter(coin => coin.price_change_percentage_24h < -3).slice(0, 10);
                
                output.innerHTML += `<span class="success">Found ${bullishCandidates.length} bullish candidates (>3% 24h) and ${bearishCandidates.length} bearish candidates (<-3% 24h).</span>\nAnalyzing each with Gemini AI for ICT confluence...\n\n`;

                const validTrades = { longs: [], shorts: [] };

                // Helper function to analyze a candidate
                async function analyzeCandidate(coin, direction) {
                    const id = coin.id;
                    const symbol = coin.symbol.toUpperCase();
                    const currentPrice = coin.current_price;
                    const change24h = coin.price_change_percentage_24h.toFixed(2);

                    let bias = 'Invalid';
                    let entry = null, sl = null, tp = null, rr = 0;

                    try {
                        // Fetch 1-day 5min closes for LTF/MTF
                        const from1d = Math.floor((Date.now() / 1000) - 86400);
                        const toNow = Math.floor(Date.now() / 1000);
                        const chart1dUrl = `${BASE_URL}/coins/${id}/market_chart/range`;
                        const chart1dParams = new URLSearchParams({ vs_currency: 'usd', from: from1d, to: toNow });
                        const chart1dRes = await fetch(`${chart1dUrl}?${chart1dParams}`, { headers: HEADERS });
                        
                        if (!chart1dRes.ok) {
                            return { success: false, msg: ` (Chart fetch failed: ${chart1dRes.status} - Skipping ${symbol})` };
                        }
                        
                        const chart1dData = await chart1dRes.json();
                        const prices1d = chart1dData.prices || [];
                        const closes1d = prices1d.map(p => p[1]);

                        if (closes1d.length < 20) {
                            return { success: false, msg: ` (Low data: Skipping ${symbol})` };
                        }

                        // Fetch 7-day hourly for HTF H1
                        const from7d = Math.floor((Date.now() / 1000) - 7 * 86400);
                        const chart7dUrl = `${BASE_URL}/coins/${id}/market_chart/range`;
                        const chart7dParams = new URLSearchParams({ vs_currency: 'usd', from: from7d, to: toNow });
                        const chart7dRes = await fetch(`${chart7dUrl}?${chart7dParams}`, { headers: HEADERS });
                        
                        if (!chart7dRes.ok) {
                            return { success: false, msg: ` (7D chart failed: Skipping ${symbol})` };
                        }
                        
                        const chart7dData = await chart7dRes.json();
                        const prices7d = chart7dData.prices || [];
                        const closes7d = prices7d.map(p => p[1]);

                        if (closes7d.length < 24) {
                            return { success: false, msg: ` (Low 7D data: Skipping ${symbol})` };
                        }

                        // Prepare data for Gemini
                        const recent1d = closes1d.slice(-50).join(', ');
                        const recent7d = closes7d.slice(-50).join(', ');
                        
                        let prompt = '';
                        if (direction === 'bullish') {
                            prompt = `You are an expert ICT (Inner Circle Trader) sniper for crypto longs. Analyze for high-probability long setup.

Symbol: ${symbol}
Current Price: $${currentPrice.toFixed(4)}
24h Change: +${change24h}%
Session: ${timeNote}

Price Data:
- Recent 1-day 5min closes (last 50): [${recent1d}]
- Recent 7-day hourly closes (last 50): [${recent7d}]

Rules for valid setup:
- HTF (H1/7d): Bullish structure (higher highs & higher lows).
- MTF (M15 approx): Price above 20-period MA.
- LTF (M5): In 61.8% Fibonacci OTE retracement of recent upswing, during kill zone or Asian bias.
- Overall: Positive momentum, confluence across timeframes.

If valid, suggest:
- Bias: 'Bullish (HTF HH/HL BOS, MTF MA confluence, LTF OTE retrace)'
- Entry: Near current price
- SL: ~0.5% below recent swing low or structure
- TP: 3:1 RR from entry/SL
- RR: 3
- Notes: Include session context

Else: Bias 'Invalid'

Respond ONLY with valid JSON (no extra text):
{
  "bias": "Bullish ... or Invalid",
  "entry": number or null,
  "sl": number or null,
  "tp": number or null,
  "rr": number or 0,
  "notes": "string"
}`;
                        } else { // bearish
                            prompt = `You are an expert ICT sniper for crypto shorts. Analyze for high-probability short setup.

Symbol: ${symbol}
Current Price: $${currentPrice.toFixed(4)}
24h Change: ${change24h}% (negative momentum)
Session: ${timeNote}

Price Data:
- Recent 1-day 5min closes (last 50): [${recent1d}]
- Recent 7-day hourly closes (last 50): [${recent7d}]

Rules for valid setup:
- HTF (H1/7d): Bearish structure (lower highs & lower lows).
- MTF (M15 approx): Price below 20-period MA.
- LTF (M5): In 61.8% Fibonacci OTE retracement of recent downswing, during kill zone or Asian bias.
- Overall: Negative momentum, confluence across timeframes.

If valid, suggest:
- Bias: 'Bearish (HTF LH/LL BOS, MTF MA confluence, LTF OTE retrace)'
- Entry: Near current price
- SL: ~0.5% above recent swing high or structure
- TP: 3:1 RR from entry/SL (downward)
- RR: 3
- Notes: Include session context

Else: Bias 'Invalid'

Respond ONLY with valid JSON (no extra text):
{
  "bias": "Bearish ... or Invalid",
  "entry": number or null,
  "sl": number or null,
  "tp": number or null,
  "rr": number or 0,
  "notes": "string"
}`;
                        }

                        const analysis = await callGemini(prompt);

                        if (analysis.bias && analysis.bias !== 'Invalid' && analysis.entry && analysis.sl && analysis.tp) {
                            bias = analysis.bias;
                            entry = analysis.entry;
                            sl = analysis.sl;
                            tp = analysis.tp;
                            rr = analysis.rr || 3;

                            // Lot size: Position USD = risk $1 / (SL dist %) 
                            const slDistance = Math.abs(entry - sl);
                            const riskPct = slDistance / entry;
                            const positionUSD = 1 / riskPct;
                            const lotSize = (positionUSD / entry).toFixed(4); // In crypto units

                            return {
                                success: true,
                                trade: {
                                    name: coin.name,
                                    symbol,
                                    entry: entry.toFixed(4),
                                    sl: sl.toFixed(4),
                                    tp: tp.toFixed(4),
                                    lotSize,
                                    rr,
                                    notes: `${analysis.notes} | 24h: ${change24h}% | AI-Powered ICT Analysis`,
                                    direction: direction === 'bullish' ? 'Long' : 'Short'
                                }
                            };
                        }
                    } catch (coinError) {
                        return { success: false, msg: ` (Coin error for ${symbol}: ${coinError.message} - Skipping)` };
                    }

                    return { success: false, msg: ' done.\n' };
                }

                // Analyze bullish candidates
                output.innerHTML += '--- Bullish Analysis ---\n';
                for (let i = 0; i < bullishCandidates.length; i++) {
                    const coin = bullishCandidates[i];
                    const symbol = coin.symbol.toUpperCase();
                    output.innerHTML += `Checking ${symbol} (bullish)...`;
                    
                    const result = await analyzeCandidate(coin, 'bullish');
                    output.innerHTML += result.msg || '';
                    
                    if (result.success) {
                        validTrades.longs.push(result.trade);
                    }
                    
                    // Tiny delay to respect rate limits
                    await new Promise(resolve => setTimeout(resolve, 100));
                }

                // Analyze bearish candidates
                output.innerHTML += '\n--- Bearish Analysis ---\n';
                for (let i = 0; i < bearishCandidates.length; i++) {
                    const coin = bearishCandidates[i];
                    const symbol = coin.symbol.toUpperCase();
                    output.innerHTML += `Checking ${symbol} (bearish)...`;
                    
                    const result = await analyzeCandidate(coin, 'bearish');
                    output.innerHTML += result.msg || '';
                    
                    if (result.success) {
                        validTrades.shorts.push(result.trade);
                    }
                    
                    // Tiny delay to respect rate limits
                    await new Promise(resolve => setTimeout(resolve, 100));
                }

                output.innerHTML += '\n';

                // Output summaries
                output.innerHTML += '=== TIMEFRAME SUMMARIES (Global) ===\n';
                output.innerHTML += 'HTF (H1): Bullish bias via HH/HL structure breaks (BOS). Bearish via LH/LL. Liquidity targeted above/below recent highs/lows.\n';
                output.innerHTML += 'MTF (M15): Confluence if price >/< 20-MA, aligning with HTF.\n';
                output.innerHTML += 'LTF (M1): Precision at 61.8% Fib OTE on recent displacement.\n\n';

                // Output longs
                const totalLongs = validTrades.longs.length;
                if (totalLongs === 0) {
                    output.innerHTML += '<span class="error">No Valid Long Trades: No Bullish Setup or Risk/Reward Violated.</span>\n';
                } else {
                    output.innerHTML += `<span class="success">=== Valid Sniper Long Trade Plans (${totalLongs} found via Gemini AI) ===</span>\n`;
                    validTrades.longs.forEach((trade, idx) => {
                        output.innerHTML += `<span class="long">${idx+1}. ${trade.name} (${trade.symbol})</span>\n`;
                        output.innerHTML += `Valid Sniper Trade Plan: ${trade.direction} | Entry: $${trade.entry} | SL: $${trade.sl} | TP: $${trade.tp} | Lot Size: ${trade.lotSize} ${trade.symbol} | RR: ${trade.rr}:1 | Notes: ${trade.notes}.\n\n`;
                    });
                }

                // Output shorts
                const totalShorts = validTrades.shorts.length;
                if (totalShorts === 0) {
                    output.innerHTML += '<span class="error">No Valid Short Trades: No Bearish Setup or Risk/Reward Violated.</span>\n';
                } else {
                    output.innerHTML += `<span class="success">=== Valid Sniper Short Trade Plans (${totalShorts} found via Gemini AI) ===</span>\n`;
                    validTrades.shorts.forEach((trade, idx) => {
                        output.innerHTML += `<span class="short">${idx+1}. ${trade.name} (${trade.symbol})</span>\n`;
                        output.innerHTML += `Valid Sniper Trade Plan: ${trade.direction} | Entry: $${trade.entry} | SL: $${trade.sl} | TP: $${trade.tp} | Lot Size: ${trade.lotSize} ${trade.symbol} | RR: ${trade.rr}:1 | Notes: ${trade.notes}.\n\n`;
                    });
                }

                if (totalLongs === 0 && totalShorts === 0) {
                    output.innerHTML += 'Tip: Market might be flat—try lowering threshold to >1% / <-1% in code (lines ~120-121). Check Gemini prompt for refinements.\n';
                }

                output.innerHTML += '\nPitfalls: Avoid overtrading outside kill zones; wait for structure confirmation. Study ICT: Focus on PO3 cycles, FVGs, OBs for refinement. Gemini analysis is AI-assisted—verify manually.\n';

            } catch (error) {
                output.innerHTML += `<span class="error">Global Error: ${error.message} (Check connection or API key).</span>\n`;
            }
        }
    </script>
</body>
    </html>
