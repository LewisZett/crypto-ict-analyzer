<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypto ICT Sniper App</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 10px; background: #f4f4f4; }
        button { background: #007bff; color: white; padding: 10px; border: none; border-radius: 5px; width: 100%; font-size: 16px; }
        #output { margin-top: 20px; white-space: pre-wrap; background: white; padding: 10px; border-radius: 5px; overflow: auto; }
        h1, h2 { color: #333; }
        .error { color: red; }
        .success { color: green; }
        input { width: 100%; padding: 10px; margin: 5px 0; border: 1px solid #ccc; border-radius: 5px; }
    </style>
</head>
<body>
    <h1>Crypto ICT Price Action Analysis App</h1>
    <p>Now integrated with Google Gemini AI for advanced ICT analysis (requires free API key from <a href="https://aistudio.google.com/app/apikey" target="_blank">Google AI Studio</a>).</p>
    <label for="geminiKey">Gemini API Key:</label>
    <input type="password" id="geminiKey" placeholder="Paste your Gemini API key here">
    <button onclick="runAnalysis()">Run ICT Analysis</button>
    <div id="output"></div>

    <script>
        // No API key needed for public mode
        const API_KEY = ''; // Empty for free public API
        const BASE_URL = 'https://api.coingecko.com/api/v3'; // Public endpoint
        const HEADERS = {}; // No auth headers

        let GEMINI_API_KEY = '';

        async function callGemini(prompt) {
            if (!GEMINI_API_KEY) {
                throw new Error('Gemini API key not provided');
            }
            const url = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent';
            const body = {
                contents: [{
                    parts: [{ text: prompt }]
                }]
            };
            const res = await fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-goog-api-key': GEMINI_API_KEY
                },
                body: JSON.stringify(body)
            });
            if (!res.ok) {
                const errorText = await res.text();
                throw new Error(`Gemini API error (${res.status}): ${errorText}`);
            }
            const data = await res.json();
            const text = data.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!text) {
                throw new Error('No response from Gemini');
            }
            // Extract JSON from response (handle markdown if present)
            const jsonMatch = text.match(/```json\s*(\{.*?\})\s*```/s) || [null, text.trim()];
            try {
                return JSON.parse(jsonMatch[1]);
            } catch (e) {
                throw new Error(`Failed to parse JSON from Gemini: ${e.message}`);
            }
        }

        async function runAnalysis() {
            GEMINI_API_KEY = document.getElementById('geminiKey').value.trim();
            const output = document.getElementById('output');
            output.innerHTML = 'Analyzing... (may take 1-2 min due to API calls)\n';
            
            if (!GEMINI_API_KEY) {
                output.innerHTML += '<span class="error">Please enter your Gemini API key!</span>\n';
                return;
            }
            
            try {
                // Step 0: Get current time in GMT+2 (Johannesburg)
                const now = new Date();
                const saOptions = { timeZone: 'Africa/Johannesburg', hour: 'numeric', minute: 'numeric', hour12: false };
                const saTime = now.toLocaleTimeString('en-US', saOptions);
                const [hourStr, minStr] = saTime.split(':');
                const hour = parseInt(hourStr);
                const minute = parseInt(minStr);
                const isLKZ = (hour >= 9 && hour < 12);
                const isNYKZ = (hour >= 15 && (hour > 15 || minute >= 30) && hour < 18);
                const isAsian = (hour >= 1 && hour < 9);
                const inKillZone = isLKZ || isNYKZ;
                const timeNote = `Current time: ${saTime} GMT+2 | Kill Zone: ${inKillZone ? 'Yes (High Prob)' : 'No (Use Asian Bias)'} | LKZ: ${isLKZ}, NYKZ: ${isNYKZ}, Asian: ${isAsian}`;

                output.innerHTML += `${timeNote}\n`;
                output.innerHTML += `Using Gemini AI for ICT analysis (API key set).\n\n`;

                // Fetch top 50 cryptos
                const marketsUrl = `${BASE_URL}/coins/markets`;
                const marketsParams = new URLSearchParams({
                    vs_currency: 'usd',
                    order: 'market_cap_desc',
                    per_page: 50,
                    page: 1,
                    sparkline: false,
                    price_change_percentage: '24h'
                });
                const marketsRes = await fetch(`${marketsUrl}?${marketsParams}`, { headers: HEADERS });
                
                if (!marketsRes.ok) {
                    const errorText = await marketsRes.text();
                    output.innerHTML += `<span class="error">API Error (${marketsRes.status}): ${errorText}</span>\n`;
                    return;
                }
                
                const topCryptosRaw = await marketsRes.json();
                if (!Array.isArray(topCryptosRaw)) {
                    output.innerHTML += `<span class="error">Invalid API response (not an array): ${JSON.stringify(topCryptosRaw)}</span>\n`;
                    return;
                }
                const topCryptos = topCryptosRaw;

                // Filter very positive: >3% 24h change
                const positiveCandidates = topCryptos.filter(coin => coin.price_change_percentage_24h > 3).slice(0, 15); // Reduced for rate limits
                output.innerHTML += `<span class="success">Found ${positiveCandidates.length} candidates with >3% 24h gain.</span>\nAnalyzing each with Gemini AI for ICT confluence...\n\n`;

                const validTrades = [];

                for (let i = 0; i < positiveCandidates.length; i++) {
                    const coin = positiveCandidates[i];
                    const id = coin.id;
                    const symbol = coin.symbol.toUpperCase();
                    const currentPrice = coin.current_price;
                    const change24h = coin.price_change_percentage_24h.toFixed(2);

                    output.innerHTML += `Checking ${symbol}...`; // Progress

                    let bias = 'Invalid';
                    let entry = null, sl = null, tp = null, rr = 0;

                    try {
                        // Fetch 1-day 5min closes for LTF/MTF
                        const from1d = Math.floor((Date.now() / 1000) - 86400);
                        const toNow = Math.floor(Date.now() / 1000);
                        const chart1dUrl = `${BASE_URL}/coins/${id}/market_chart/range`;
                        const chart1dParams = new URLSearchParams({ vs_currency: 'usd', from: from1d, to: toNow });
                        const chart1dRes = await fetch(`${chart1dUrl}?${chart1dParams}`, { headers: HEADERS });
                        
                        if (!chart1dRes.ok) {
                            output.innerHTML += ` (Chart fetch failed: ${chart1dRes.status} - Skipping ${symbol})\n`;
                            continue;
                        }
                        
                        const chart1dData = await chart1dRes.json();
                        const prices1d = chart1dData.prices || [];
                        const closes1d = prices1d.map(p => p[1]);

                        if (closes1d.length < 20) {
                            output.innerHTML += ` (Low data: Skipping ${symbol})\n`;
                            continue;
                        }

                        // Fetch 7-day hourly for HTF H1
                        const from7d = Math.floor((Date.now() / 1000) - 7 * 86400);
                        const chart7dUrl = `${BASE_URL}/coins/${id}/market_chart/range`;
                        const chart7dParams = new URLSearchParams({ vs_currency: 'usd', from: from7d, to: toNow });
                        const chart7dRes = await fetch(`${chart7dUrl}?${chart7dParams}`, { headers: HEADERS });
                        
                        if (!chart7dRes.ok) {
                            output.innerHTML += ` (7D chart failed: Skipping ${symbol})\n`;
                            continue;
                        }
                        
                        const chart7dData = await chart7dRes.json();
                        const prices7d = chart7dData.prices || [];
                        const closes7d = prices7d.map(p => p[1]);

                        if (closes7d.length < 24) {
                            output.innerHTML += ` (Low 7D data: Skipping ${symbol})\n`;
                            continue;
                        }

                        // Prepare data for Gemini
                        const recent1d = closes1d.slice(-50).join(', ');
                        const recent7d = closes7d.slice(-50).join(', ');
                        const prompt = `You are an expert ICT (Inner Circle Trader) sniper for crypto longs. Analyze for high-probability long setup.

Symbol: ${symbol}
Current Price: $${currentPrice.toFixed(4)}
24h Change: +${change24h}%
Session: ${timeNote}

Price Data:
- Recent 1-day 5min closes (last 50): [${recent1d}]
- Recent 7-day hourly closes (last 50): [${recent7d}]

Rules for valid setup:
- HTF (H1/7d): Bullish structure (higher highs & higher lows).
- MTF (M15 approx): Price above 20-period MA.
- LTF (M5): In 61.8% Fibonacci OTE retracement of recent upswing, during kill zone or Asian bias.
- Overall: Positive momentum, confluence across timeframes.

If valid, suggest:
- Bias: 'Bullish (HTF HH/HL BOS, MTF MA confluence, LTF OTE retrace)'
- Entry: Near current price
- SL: ~0.5% below recent swing low or structure
- TP: 3:1 RR from entry/SL
- RR: 3
- Notes: Include session context

Else: Bias 'Invalid'

Respond ONLY with valid JSON (no extra text):
{
  "bias": "Bullish ... or Invalid",
  "entry": number or null,
  "sl": number or null,
  "tp": number or null,
  "rr": number or 0,
  "notes": "string"
}`;

                        const analysis = await callGemini(prompt);

                        if (analysis.bias && analysis.bias !== 'Invalid' && analysis.entry && analysis.sl && analysis.tp) {
                            bias = analysis.bias;
                            entry = analysis.entry;
                            sl = analysis.sl;
                            tp = analysis.tp;
                            rr = analysis.rr || 3;

                            // Lot size: Position USD = risk $1 / (SL dist %) 
                            const slDistance = Math.abs(entry - sl);
                            const riskPct = slDistance / entry;
                            const positionUSD = 1 / riskPct;
                            const lotSize = (positionUSD / entry).toFixed(4); // In crypto units

                            validTrades.push({
                                name: coin.name,
                                symbol,
                                entry: entry.toFixed(4),
                                sl: sl.toFixed(4),
                                tp: tp.toFixed(4),
                                lotSize,
                                rr,
                                notes: `${analysis.notes} | 24h: +${change24h}% | AI-Powered ICT Analysis`
                            });
                        }
                    } catch (coinError) {
                        output.innerHTML += ` (Coin error for ${symbol}: ${coinError.message} - Skipping)\n`;
                        continue;
                    }

                    output.innerHTML += ` done.\n`;
                    
                    // Tiny delay to respect rate limits
                    await new Promise(resolve => setTimeout(resolve, 100));
                }

                output.innerHTML += '\n';

                // Output summaries
                output.innerHTML += '=== TIMEFRAME SUMMARIES (Global) ===\n';
                output.innerHTML += 'HTF (H1): Bullish bias via HH/HL structure breaks (BOS). Liquidity above recent highs targeted.\n';
                output.innerHTML += 'MTF (M15): Confluence if price > 20-MA, aligning with HTF.\n';
                output.innerHTML += 'LTF (M1): Precision at 61.8% Fib OTE on recent displacement.\n\n';

                if (validTrades.length === 0) {
                    output.innerHTML += '<span class="error">No Valid Trade: No Setup or Risk/Reward Violated.</span>\n';
                    output.innerHTML += 'Tip: Market might be flat—try lowering threshold to >1% in code (line ~110). Check Gemini prompt for refinements.\n';
                } else {
                    output.innerHTML += `<span class="success">=== Valid Sniper Trade Plans (${validTrades.length} found via Gemini AI) ===</span>\n`;
                    validTrades.slice(0, 20).forEach((trade, idx) => { // Up to 20, but aim 10+
                        output.innerHTML += `${idx+1}. ${trade.name} (${trade.symbol})\n`;
                        output.innerHTML += `Valid Sniper Trade Plan: Long | Entry: $${trade.entry} | SL: $${trade.sl} | TP: $${trade.tp} | Lot Size: ${trade.lotSize} ${trade.symbol} | RR: ${trade.rr}:1 | Notes: ${trade.notes}.\n\n`;
                    });
                }

                output.innerHTML += '\nPitfalls: Avoid overtrading outside kill zones; wait for structure confirmation. Study ICT: Focus on PO3 cycles, FVGs, OBs for refinement. Gemini analysis is AI-assisted—verify manually.\n';

            } catch (error) {
                output.innerHTML += `<span class="error">Global Error: ${error.message} (Check connection or API key).</span>\n`;
            }
        }
    </script>
</body>
</html>                    
